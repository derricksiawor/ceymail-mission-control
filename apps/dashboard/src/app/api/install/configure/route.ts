import { NextRequest, NextResponse } from "next/server";
import { spawnSync } from "child_process";
import { resolve } from "path";
import { getConfig } from "@/lib/config/config";

interface ConfigFile {
  name: string;
  path: string;
  content: string;
}

// Allowed config paths for sudo tee
const ALLOWED_CONFIG_PREFIXES = [
  "/etc/postfix/",
  "/etc/dovecot/",
  "/etc/opendkim/",
  "/etc/spamassassin/",
];

function sudoWriteFile(filePath: string, content: string, mode?: string): { success: boolean; error?: string } {
  // Resolve to canonical path to prevent traversal (e.g. /etc/postfix/../../etc/shadow)
  const path = resolve(filePath);

  // Validate path is within allowed config directories
  if (!ALLOWED_CONFIG_PREFIXES.some((prefix) => path.startsWith(prefix))) {
    return { success: false, error: `Path ${path} is not in allowed config directories` };
  }

  // Ensure parent directory exists
  const dir = path.substring(0, path.lastIndexOf("/"));
  spawnSync("/usr/bin/sudo", ["/usr/bin/mkdir", "-p", dir], {
    encoding: "utf8",
    timeout: 5000,
  });

  // Write content via sudo tee
  const result = spawnSync("/usr/bin/sudo", ["/usr/bin/tee", path], {
    input: content,
    encoding: "utf8",
    timeout: 10000,
  });

  if (result.status !== 0) {
    return { success: false, error: (result.stderr || "").trim() || "Write failed" };
  }

  // Set permissions if specified
  if (mode) {
    spawnSync("/usr/bin/sudo", ["/usr/bin/chmod", mode, path], {
      encoding: "utf8",
      timeout: 5000,
    });
  }

  return { success: true };
}

// POST - Generate and write service configuration files
export async function POST(request: NextRequest) {
  try {
    const role = request.headers.get("x-user-role");
    if (role !== "admin") {
      return NextResponse.json({ error: "Admin access required" }, { status: 403 });
    }

    let body: Record<string, unknown>;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid or missing JSON body" }, { status: 400 });
    }

    const { hostname, mailDomain, adminEmail, phpVersion = "8.2", writeFiles = false } = body as {
      hostname?: string;
      mailDomain?: string;
      adminEmail?: string;
      phpVersion?: string;
      writeFiles?: boolean;
    };

    if (!hostname || typeof hostname !== "string") {
      return NextResponse.json({ error: "Hostname is required" }, { status: 400 });
    }
    if (!mailDomain || typeof mailDomain !== "string") {
      return NextResponse.json({ error: "Mail domain is required" }, { status: 400 });
    }
    if (!adminEmail || typeof adminEmail !== "string") {
      return NextResponse.json({ error: "Admin email is required" }, { status: 400 });
    }

    // Validate formats
    if (!/^[a-zA-Z0-9][a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(hostname)) {
      return NextResponse.json({ error: "Invalid hostname format" }, { status: 400 });
    }
    if (!/^[a-zA-Z0-9][a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(mailDomain)) {
      return NextResponse.json({ error: "Invalid domain format" }, { status: 400 });
    }

    const config = getConfig();
    if (!config?.database.password) {
      return NextResponse.json(
        { error: "Database configuration not found. Complete the setup wizard first." },
        { status: 400 }
      );
    }
    const dbPassword = config.database.password;

    // Generate configuration files
    const configs: ConfigFile[] = [];

    // 1. Postfix main.cf
    configs.push({
      name: "postfix/main.cf",
      path: "/etc/postfix/main.cf",
      content: [
        `# CeyMail Postfix Configuration`,
        `# Generated by Mission Control`,
        ``,
        `myhostname = ${hostname}`,
        `mydomain = ${mailDomain}`,
        `myorigin = $mydomain`,
        `inet_interfaces = all`,
        `inet_protocols = all`,
        `mydestination = $myhostname, localhost.$mydomain, localhost`,
        ``,
        `# TLS`,
        `smtpd_tls_cert_file = /etc/letsencrypt/live/${hostname}/fullchain.pem`,
        `smtpd_tls_key_file = /etc/letsencrypt/live/${hostname}/privkey.pem`,
        `smtpd_use_tls = yes`,
        `smtpd_tls_security_level = may`,
        `smtpd_tls_auth_only = yes`,
        `smtp_tls_security_level = may`,
        `smtp_tls_loglevel = 1`,
        ``,
        `# SASL Authentication`,
        `smtpd_sasl_type = dovecot`,
        `smtpd_sasl_path = private/auth`,
        `smtpd_sasl_auth_enable = yes`,
        `smtpd_sasl_security_options = noanonymous`,
        `smtpd_sasl_local_domain = $myhostname`,
        ``,
        `# Virtual mailbox`,
        `virtual_transport = lmtp:unix:private/dovecot-lmtp`,
        `virtual_mailbox_domains = mysql:/etc/postfix/mysql-virtual-mailbox-domains.cf`,
        `virtual_mailbox_maps = mysql:/etc/postfix/mysql-virtual-mailbox-maps.cf`,
        `virtual_alias_maps = mysql:/etc/postfix/mysql-virtual-alias-maps.cf`,
        ``,
        `# DKIM`,
        `milter_default_action = accept`,
        `milter_protocol = 6`,
        `smtpd_milters = local:opendkim/opendkim.sock`,
        `non_smtpd_milters = $smtpd_milters`,
        ``,
        `# Restrictions`,
        `smtpd_recipient_restrictions =`,
        `    permit_sasl_authenticated,`,
        `    permit_mynetworks,`,
        `    reject_unauth_destination,`,
        `    reject_invalid_hostname,`,
        `    reject_non_fqdn_hostname,`,
        `    reject_non_fqdn_sender,`,
        `    reject_non_fqdn_recipient,`,
        `    reject_unknown_sender_domain,`,
        `    reject_rbl_client zen.spamhaus.org`,
        ``,
        `# Size limits`,
        `message_size_limit = 52428800`,
        `mailbox_size_limit = 0`,
      ].join("\n"),
    });

    // 2. Postfix MySQL lookup files
    configs.push({
      name: "postfix/mysql-virtual-mailbox-domains.cf",
      path: "/etc/postfix/mysql-virtual-mailbox-domains.cf",
      content: [
        `user = ceymail`,
        `password = ${dbPassword}`,
        `hosts = 127.0.0.1`,
        `dbname = ceymail`,
        `query = SELECT 1 FROM virtual_domains WHERE name='%s'`,
      ].join("\n"),
    });

    configs.push({
      name: "postfix/mysql-virtual-mailbox-maps.cf",
      path: "/etc/postfix/mysql-virtual-mailbox-maps.cf",
      content: [
        `user = ceymail`,
        `password = ${dbPassword}`,
        `hosts = 127.0.0.1`,
        `dbname = ceymail`,
        `query = SELECT 1 FROM virtual_users WHERE email='%s'`,
      ].join("\n"),
    });

    configs.push({
      name: "postfix/mysql-virtual-alias-maps.cf",
      path: "/etc/postfix/mysql-virtual-alias-maps.cf",
      content: [
        `user = ceymail`,
        `password = ${dbPassword}`,
        `hosts = 127.0.0.1`,
        `dbname = ceymail`,
        `query = SELECT destination FROM virtual_aliases WHERE source='%s'`,
      ].join("\n"),
    });

    // 3. Dovecot configuration
    configs.push({
      name: "dovecot/dovecot.conf",
      path: "/etc/dovecot/dovecot.conf",
      content: [
        `# CeyMail Dovecot Configuration`,
        `# Generated by Mission Control`,
        ``,
        `protocols = imap lmtp sieve`,
        `listen = *, ::`,
        ``,
        `ssl = required`,
        `ssl_cert = </etc/letsencrypt/live/${hostname}/fullchain.pem`,
        `ssl_key = </etc/letsencrypt/live/${hostname}/privkey.pem`,
        `ssl_min_protocol = TLSv1.2`,
        ``,
        `mail_location = maildir:/var/mail/vhosts/%d/%n`,
        `mail_privileged_group = mail`,
        ``,
        `auth_mechanisms = plain login`,
        ``,
        `passdb {`,
        `  driver = sql`,
        `  args = /etc/dovecot/dovecot-sql.conf.ext`,
        `}`,
        ``,
        `userdb {`,
        `  driver = static`,
        `  args = uid=vmail gid=vmail home=/var/mail/vhosts/%d/%n`,
        `}`,
        ``,
        `service lmtp {`,
        `  unix_listener /var/spool/postfix/private/dovecot-lmtp {`,
        `    mode = 0600`,
        `    user = postfix`,
        `    group = postfix`,
        `  }`,
        `}`,
        ``,
        `service auth {`,
        `  unix_listener /var/spool/postfix/private/auth {`,
        `    mode = 0660`,
        `    user = postfix`,
        `    group = postfix`,
        `  }`,
        `  unix_listener auth-userdb {`,
        `    mode = 0600`,
        `    user = vmail`,
        `  }`,
        `}`,
      ].join("\n"),
    });

    // 4. Dovecot SQL configuration
    configs.push({
      name: "dovecot/dovecot-sql.conf.ext",
      path: "/etc/dovecot/dovecot-sql.conf.ext",
      content: [
        `driver = mysql`,
        `connect = host=127.0.0.1 dbname=ceymail user=ceymail password=${dbPassword}`,
        `default_pass_scheme = SHA512-CRYPT`,
        `password_query = SELECT email as user, password FROM virtual_users WHERE email='%u'`,
      ].join("\n"),
    });

    // 5. OpenDKIM configuration
    configs.push({
      name: "opendkim/opendkim.conf",
      path: "/etc/opendkim/opendkim.conf",
      content: [
        `# CeyMail OpenDKIM Configuration`,
        `# Generated by Mission Control`,
        ``,
        `Syslog yes`,
        `SyslogSuccess yes`,
        `LogWhy yes`,
        `UMask 007`,
        `Mode sv`,
        `Canonicalization relaxed/simple`,
        ``,
        `Domain ${mailDomain}`,
        `Selector mail`,
        `KeyFile /etc/opendkim/keys/${mailDomain}/mail.private`,
        ``,
        `Socket local:/var/spool/postfix/opendkim/opendkim.sock`,
        `PidFile /run/opendkim/opendkim.pid`,
        ``,
        `OversignHeaders From`,
        `TrustAnchorFile /usr/share/dns/root.key`,
        ``,
        `KeyTable /etc/opendkim/key.table`,
        `SigningTable refile:/etc/opendkim/signing.table`,
        `ExternalIgnoreList /etc/opendkim/trusted.hosts`,
        `InternalHosts /etc/opendkim/trusted.hosts`,
      ].join("\n"),
    });

    // 6. OpenDKIM key table, signing table, trusted hosts
    configs.push({
      name: "opendkim/key.table",
      path: "/etc/opendkim/key.table",
      content: `mail._domainkey.${mailDomain} ${mailDomain}:mail:/etc/opendkim/keys/${mailDomain}/mail.private`,
    });

    configs.push({
      name: "opendkim/signing.table",
      path: "/etc/opendkim/signing.table",
      content: `*@${mailDomain} mail._domainkey.${mailDomain}`,
    });

    configs.push({
      name: "opendkim/trusted.hosts",
      path: "/etc/opendkim/trusted.hosts",
      content: [
        `127.0.0.1`,
        `localhost`,
        `${mailDomain}`,
      ].join("\n"),
    });

    // 7. SpamAssassin local.cf
    configs.push({
      name: "spamassassin/local.cf",
      path: "/etc/spamassassin/local.cf",
      content: [
        `# CeyMail SpamAssassin Configuration`,
        `# Generated by Mission Control`,
        ``,
        `required_score 5.0`,
        `rewrite_header Subject [SPAM]`,
        `report_safe 0`,
        `use_bayes 1`,
        `bayes_auto_learn 1`,
        `skip_rbl_checks 0`,
        `use_razor2 0`,
        `use_pyzor 0`,
      ].join("\n"),
    });

    // Helper to redact DB password from config content
    const redactPassword = (content: string) =>
      content.replace(new RegExp(dbPassword.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), "********");

    // If writeFiles is true, actually write the configs to disk via sudo
    if (writeFiles) {
      const results: { name: string; status: "written" | "failed"; error?: string }[] = [];

      for (const cfg of configs) {
        // Write sensitive files (containing DB password) with mode 640 from the start
        const isSensitive = cfg.name.includes("mysql-virtual") || cfg.name === "dovecot/dovecot-sql.conf.ext";
        const writeResult = sudoWriteFile(cfg.path, cfg.content, isSensitive ? "640" : "644");
        if (writeResult.success) {
          results.push({ name: cfg.name, status: "written" });
        } else {
          results.push({ name: cfg.name, status: "failed", error: writeResult.error });
        }
      }

      // Validate postfix config
      let postfixValid = false;
      const postconfResult = spawnSync("/usr/bin/sudo", ["/usr/sbin/postconf", "-n"], {
        encoding: "utf8",
        timeout: 5000,
      });
      postfixValid = postconfResult.status === 0;

      return NextResponse.json({
        configs: configs.map((c) => ({ name: c.name, content: redactPassword(c.content) })),
        writeResults: results,
        postfixValid,
      });
    }

    // Return generated configs for preview with password redacted
    return NextResponse.json({
      configs: configs.map((c) => ({
        name: c.name,
        content: redactPassword(c.content),
      })),
    });
  } catch (error) {
    console.error("Error generating configs:", error);
    return NextResponse.json(
      { error: "Failed to generate configurations" },
      { status: 500 }
    );
  }
}
