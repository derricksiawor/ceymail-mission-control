import { NextRequest, NextResponse } from "next/server";
import { execFileSync } from "child_process";
import { writeFileSync, existsSync, mkdirSync, readFileSync } from "fs";
import { join } from "path";
import { getConfig } from "@/lib/config/config";

interface ConfigFile {
  name: string;
  path: string;
  content: string;
}

// POST - Generate and write service configuration files
export async function POST(request: NextRequest) {
  try {
    let body: Record<string, unknown>;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid or missing JSON body" }, { status: 400 });
    }

    const { hostname, mailDomain, adminEmail, phpVersion = "8.2", writeFiles = false } = body as {
      hostname?: string;
      mailDomain?: string;
      adminEmail?: string;
      phpVersion?: string;
      writeFiles?: boolean;
    };

    if (!hostname || typeof hostname !== "string") {
      return NextResponse.json({ error: "Hostname is required" }, { status: 400 });
    }
    if (!mailDomain || typeof mailDomain !== "string") {
      return NextResponse.json({ error: "Mail domain is required" }, { status: 400 });
    }
    if (!adminEmail || typeof adminEmail !== "string") {
      return NextResponse.json({ error: "Admin email is required" }, { status: 400 });
    }

    // Validate formats
    if (!/^[a-zA-Z0-9][a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(hostname)) {
      return NextResponse.json({ error: "Invalid hostname format" }, { status: 400 });
    }
    if (!/^[a-zA-Z0-9][a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(mailDomain)) {
      return NextResponse.json({ error: "Invalid domain format" }, { status: 400 });
    }

    const config = getConfig();
    const dbPassword = config?.database.password || "";

    // Generate configuration files
    const configs: ConfigFile[] = [];

    // 1. Postfix main.cf
    configs.push({
      name: "postfix/main.cf",
      path: "/etc/postfix/main.cf",
      content: [
        `# CeyMail Postfix Configuration`,
        `# Generated by Mission Control`,
        ``,
        `myhostname = ${hostname}`,
        `mydomain = ${mailDomain}`,
        `myorigin = $mydomain`,
        `inet_interfaces = all`,
        `inet_protocols = all`,
        `mydestination = $myhostname, localhost.$mydomain, localhost`,
        ``,
        `# TLS`,
        `smtpd_tls_cert_file = /etc/letsencrypt/live/${hostname}/fullchain.pem`,
        `smtpd_tls_key_file = /etc/letsencrypt/live/${hostname}/privkey.pem`,
        `smtpd_use_tls = yes`,
        `smtpd_tls_security_level = may`,
        `smtpd_tls_auth_only = yes`,
        `smtp_tls_security_level = may`,
        `smtp_tls_loglevel = 1`,
        ``,
        `# SASL Authentication`,
        `smtpd_sasl_type = dovecot`,
        `smtpd_sasl_path = private/auth`,
        `smtpd_sasl_auth_enable = yes`,
        `smtpd_sasl_security_options = noanonymous`,
        `smtpd_sasl_local_domain = $myhostname`,
        ``,
        `# Virtual mailbox`,
        `virtual_transport = lmtp:unix:private/dovecot-lmtp`,
        `virtual_mailbox_domains = mysql:/etc/postfix/mysql-virtual-mailbox-domains.cf`,
        `virtual_mailbox_maps = mysql:/etc/postfix/mysql-virtual-mailbox-maps.cf`,
        `virtual_alias_maps = mysql:/etc/postfix/mysql-virtual-alias-maps.cf`,
        ``,
        `# DKIM`,
        `milter_default_action = accept`,
        `milter_protocol = 6`,
        `smtpd_milters = local:opendkim/opendkim.sock`,
        `non_smtpd_milters = $smtpd_milters`,
        ``,
        `# Restrictions`,
        `smtpd_recipient_restrictions =`,
        `    permit_sasl_authenticated,`,
        `    permit_mynetworks,`,
        `    reject_unauth_destination,`,
        `    reject_invalid_hostname,`,
        `    reject_non_fqdn_hostname,`,
        `    reject_non_fqdn_sender,`,
        `    reject_non_fqdn_recipient,`,
        `    reject_unknown_sender_domain,`,
        `    reject_rbl_client zen.spamhaus.org`,
        ``,
        `# Size limits`,
        `message_size_limit = 52428800`,
        `mailbox_size_limit = 0`,
      ].join("\n"),
    });

    // 2. Postfix MySQL lookup files
    configs.push({
      name: "postfix/mysql-virtual-mailbox-domains.cf",
      path: "/etc/postfix/mysql-virtual-mailbox-domains.cf",
      content: [
        `user = ceymail`,
        `password = ${dbPassword}`,
        `hosts = 127.0.0.1`,
        `dbname = ceymail`,
        `query = SELECT 1 FROM virtual_domains WHERE name='%s'`,
      ].join("\n"),
    });

    configs.push({
      name: "postfix/mysql-virtual-mailbox-maps.cf",
      path: "/etc/postfix/mysql-virtual-mailbox-maps.cf",
      content: [
        `user = ceymail`,
        `password = ${dbPassword}`,
        `hosts = 127.0.0.1`,
        `dbname = ceymail`,
        `query = SELECT 1 FROM virtual_users WHERE email='%s'`,
      ].join("\n"),
    });

    configs.push({
      name: "postfix/mysql-virtual-alias-maps.cf",
      path: "/etc/postfix/mysql-virtual-alias-maps.cf",
      content: [
        `user = ceymail`,
        `password = ${dbPassword}`,
        `hosts = 127.0.0.1`,
        `dbname = ceymail`,
        `query = SELECT destination FROM virtual_aliases WHERE source='%s'`,
      ].join("\n"),
    });

    // 3. Dovecot configuration
    configs.push({
      name: "dovecot/dovecot.conf",
      path: "/etc/dovecot/dovecot.conf",
      content: [
        `# CeyMail Dovecot Configuration`,
        `# Generated by Mission Control`,
        ``,
        `protocols = imap lmtp sieve`,
        `listen = *, ::`,
        ``,
        `ssl = required`,
        `ssl_cert = </etc/letsencrypt/live/${hostname}/fullchain.pem`,
        `ssl_key = </etc/letsencrypt/live/${hostname}/privkey.pem`,
        `ssl_min_protocol = TLSv1.2`,
        ``,
        `mail_location = maildir:/var/mail/vhosts/%d/%n`,
        `mail_privileged_group = mail`,
        ``,
        `auth_mechanisms = plain login`,
        ``,
        `passdb {`,
        `  driver = sql`,
        `  args = /etc/dovecot/dovecot-sql.conf.ext`,
        `}`,
        ``,
        `userdb {`,
        `  driver = static`,
        `  args = uid=vmail gid=vmail home=/var/mail/vhosts/%d/%n`,
        `}`,
        ``,
        `service lmtp {`,
        `  unix_listener /var/spool/postfix/private/dovecot-lmtp {`,
        `    mode = 0600`,
        `    user = postfix`,
        `    group = postfix`,
        `  }`,
        `}`,
        ``,
        `service auth {`,
        `  unix_listener /var/spool/postfix/private/auth {`,
        `    mode = 0666`,
        `    user = postfix`,
        `    group = postfix`,
        `  }`,
        `  unix_listener auth-userdb {`,
        `    mode = 0600`,
        `    user = vmail`,
        `  }`,
        `}`,
      ].join("\n"),
    });

    // 4. Dovecot SQL configuration
    configs.push({
      name: "dovecot/dovecot-sql.conf.ext",
      path: "/etc/dovecot/dovecot-sql.conf.ext",
      content: [
        `driver = mysql`,
        `connect = host=127.0.0.1 dbname=ceymail user=ceymail password=${dbPassword}`,
        `default_pass_scheme = SHA512-CRYPT`,
        `password_query = SELECT email as user, password FROM virtual_users WHERE email='%u'`,
      ].join("\n"),
    });

    // 5. OpenDKIM configuration
    configs.push({
      name: "opendkim/opendkim.conf",
      path: "/etc/opendkim/opendkim.conf",
      content: [
        `# CeyMail OpenDKIM Configuration`,
        `# Generated by Mission Control`,
        ``,
        `Syslog yes`,
        `SyslogSuccess yes`,
        `LogWhy yes`,
        `UMask 007`,
        `Mode sv`,
        `Canonicalization relaxed/simple`,
        ``,
        `Domain ${mailDomain}`,
        `Selector mail`,
        `KeyFile /etc/opendkim/keys/${mailDomain}/mail.private`,
        ``,
        `Socket local:/run/opendkim/opendkim.sock`,
        `PidFile /run/opendkim/opendkim.pid`,
        ``,
        `OversignHeaders From`,
        `TrustAnchorFile /usr/share/dns/root.key`,
        ``,
        `KeyTable /etc/opendkim/key.table`,
        `SigningTable refile:/etc/opendkim/signing.table`,
        `ExternalIgnoreList /etc/opendkim/trusted.hosts`,
        `InternalHosts /etc/opendkim/trusted.hosts`,
      ].join("\n"),
    });

    // 6. OpenDKIM key table, signing table, trusted hosts
    configs.push({
      name: "opendkim/key.table",
      path: "/etc/opendkim/key.table",
      content: `mail._domainkey.${mailDomain} ${mailDomain}:mail:/etc/opendkim/keys/${mailDomain}/mail.private`,
    });

    configs.push({
      name: "opendkim/signing.table",
      path: "/etc/opendkim/signing.table",
      content: `*@${mailDomain} mail._domainkey.${mailDomain}`,
    });

    configs.push({
      name: "opendkim/trusted.hosts",
      path: "/etc/opendkim/trusted.hosts",
      content: [
        `127.0.0.1`,
        `localhost`,
        `${mailDomain}`,
      ].join("\n"),
    });

    // 7. SpamAssassin local.cf
    configs.push({
      name: "spamassassin/local.cf",
      path: "/etc/spamassassin/local.cf",
      content: [
        `# CeyMail SpamAssassin Configuration`,
        `# Generated by Mission Control`,
        ``,
        `required_score 5.0`,
        `rewrite_header Subject [SPAM]`,
        `report_safe 0`,
        `use_bayes 1`,
        `bayes_auto_learn 1`,
        `skip_rbl_checks 0`,
        `use_razor2 0`,
        `use_pyzor 0`,
      ].join("\n"),
    });

    // If writeFiles is true, actually write the configs to disk
    if (writeFiles) {
      const results: { name: string; status: "written" | "failed"; error?: string }[] = [];

      for (const cfg of configs) {
        try {
          const dir = join(cfg.path, "..");
          if (!existsSync(dir)) {
            mkdirSync(dir, { recursive: true });
          }
          writeFileSync(cfg.path, cfg.content, { encoding: "utf8", mode: 0o644 });
          results.push({ name: cfg.name, status: "written" });
        } catch (writeErr: any) {
          results.push({ name: cfg.name, status: "failed", error: writeErr.message });
        }
      }

      // Validate postfix config
      let postfixValid = false;
      try {
        execFileSync("postconf", ["-n"], { encoding: "utf8", timeout: 5000 });
        postfixValid = true;
      } catch {
        // postfix config check failed
      }

      return NextResponse.json({
        configs: configs.map((c) => ({ name: c.name, content: c.content })),
        writeResults: results,
        postfixValid,
      });
    }

    // Just return generated configs for preview
    return NextResponse.json({
      configs: configs.map((c) => ({ name: c.name, content: c.content })),
    });
  } catch (error) {
    console.error("Error generating configs:", error);
    return NextResponse.json(
      { error: "Failed to generate configurations" },
      { status: 500 }
    );
  }
}
