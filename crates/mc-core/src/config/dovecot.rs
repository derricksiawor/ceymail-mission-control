use std::fmt;

/// Dovecot configuration manager.
///
/// Dovecot uses a nested brace-delimited config format rather than simple
/// key=value.  Instead of trying to round-trip arbitrary Dovecot syntax
/// we generate well-known config snippets that can be dropped into
/// /etc/dovecot/conf.d/.
#[derive(Debug, Clone)]
pub struct DovecotConfig {
    /// The primary mail domain (e.g. "example.com").
    pub domain: String,
    /// Hostname (defaults to mail.<domain>).
    pub hostname: String,
    /// Path to the SSL certificate (fullchain).
    pub ssl_cert: String,
    /// Path to the SSL private key.
    pub ssl_key: String,
    /// Base directory for virtual mailboxes.
    pub mail_home_base: String,
    /// Mail location (Maildir layout).
    pub mail_location: String,
    /// MySQL database name.
    pub db_name: String,
    /// MySQL user.
    pub db_user: String,
    /// MySQL password.
    pub db_password: String,
    /// MySQL host.
    pub db_host: String,
    /// Log path. Empty string means syslog.
    pub log_path: String,
    /// Info log path. Empty string means same as log_path.
    pub info_log_path: String,
}

#[derive(Debug)]
pub enum DovecotConfigError {
    InvalidDomain(String),
}

impl fmt::Display for DovecotConfigError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidDomain(d) => write!(f, "Invalid domain: {}", d),
        }
    }
}

impl std::error::Error for DovecotConfigError {}

impl DovecotConfig {
    /// Generate a config with secure defaults for the given domain.
    pub fn generate_default(domain: &str) -> Self {
        let hostname = format!("mail.{}", domain);
        Self {
            domain: domain.to_string(),
            hostname: hostname.clone(),
            ssl_cert: format!("/etc/letsencrypt/live/{}/fullchain.pem", hostname),
            ssl_key: format!("/etc/letsencrypt/live/{}/privkey.pem", hostname),
            mail_home_base: "/var/mail/vhosts".to_string(),
            mail_location: "maildir:/var/mail/vhosts/%d/%n/Maildir".to_string(),
            db_name: "mailserver".to_string(),
            db_user: "mailuser".to_string(),
            db_password: "changeme".to_string(),
            db_host: "127.0.0.1".to_string(),
            log_path: String::new(),
            info_log_path: String::new(),
        }
    }

    // ── sub-config generators ──────────────────────────────────────

    /// Generate 10-auth.conf
    pub fn generate_10_auth(&self) -> String {
        "\
## generated by mission-control
disable_plaintext_auth = yes
auth_mechanisms = plain login

!include auth-sql.conf.ext
"
        .to_string()
    }

    /// Generate 10-mail.conf
    pub fn generate_10_mail(&self) -> String {
        format!(
            "\
## generated by mission-control
mail_location = {}
mail_privileged_group = mail

namespace inbox {{
  inbox = yes

  mailbox Drafts {{
    auto = subscribe
    special_use = \\Drafts
  }}
  mailbox Junk {{
    auto = subscribe
    special_use = \\Junk
  }}
  mailbox Sent {{
    auto = subscribe
    special_use = \\Sent
  }}
  mailbox \"Sent Messages\" {{
    special_use = \\Sent
  }}
  mailbox Trash {{
    auto = subscribe
    special_use = \\Trash
  }}
}}
",
            self.mail_location
        )
    }

    /// Generate 10-master.conf
    pub fn generate_10_master(&self) -> String {
        "\
## generated by mission-control

service imap-login {
  inet_listener imap {
    port = 0
  }
  inet_listener imaps {
    port = 993
    ssl = yes
  }
}

service pop3-login {
  inet_listener pop3 {
    port = 0
  }
  inet_listener pop3s {
    port = 995
    ssl = yes
  }
}

service lmtp {
  unix_listener /var/spool/postfix/private/dovecot-lmtp {
    mode = 0600
    user = postfix
    group = postfix
  }
}

service auth {
  unix_listener /var/spool/postfix/private/auth {
    mode = 0660
    user = postfix
    group = postfix
  }

  unix_listener auth-userdb {
    mode = 0600
    user = vmail
  }

  user = dovecot
}

service auth-worker {
  user = vmail
}
"
        .to_string()
    }

    /// Generate 10-ssl.conf
    pub fn generate_10_ssl(&self) -> String {
        format!(
            "\
## generated by mission-control
ssl = required
ssl_cert = <{}
ssl_key = <{}
ssl_min_protocol = TLSv1.2
ssl_prefer_server_ciphers = yes
",
            self.ssl_cert, self.ssl_key
        )
    }

    /// Generate 10-logging.conf
    pub fn generate_10_logging(&self) -> String {
        let log_line = if self.log_path.is_empty() {
            "# log_path = syslog".to_string()
        } else {
            format!("log_path = {}", self.log_path)
        };
        let info_line = if self.info_log_path.is_empty() {
            "# info_log_path =".to_string()
        } else {
            format!("info_log_path = {}", self.info_log_path)
        };

        format!(
            "\
## generated by mission-control
{}
{}
auth_verbose = no
mail_debug = no
",
            log_line, info_line
        )
    }

    /// Generate auth-sql.conf.ext
    pub fn generate_auth_sql_ext(&self) -> String {
        "\
## generated by mission-control
passdb {
  driver = sql
  args = /etc/dovecot/dovecot-sql.conf.ext
}

userdb {
  driver = sql
  args = /etc/dovecot/dovecot-sql.conf.ext
}
"
        .to_string()
    }

    /// Generate dovecot-sql.conf.ext
    ///
    /// Uses parameterized queries via Dovecot's %u / %d / %n variables
    /// (NOT Rust string interpolation for query values).
    pub fn generate_dovecot_sql_ext(&self) -> String {
        format!(
            "\
## generated by mission-control
driver = mysql
connect = host={db_host} dbname={db_name} user={db_user} password={db_password}

default_pass_scheme = SHA512-CRYPT

password_query = SELECT email AS user, password FROM virtual_users WHERE email='%u'

user_query = SELECT CONCAT('{mail_home_base}/', virtual_domains.name, '/', virtual_users.email, '/') AS home, \
CONCAT('maildir:{mail_home_base}/', virtual_domains.name, '/', virtual_users.email, '/Maildir') AS mail, \
5000 AS uid, 5000 AS gid \
FROM virtual_users INNER JOIN virtual_domains ON virtual_users.domain_id = virtual_domains.id \
WHERE virtual_users.email='%u'

iterate_query = SELECT email AS user FROM virtual_users
",
            db_host = self.db_host,
            db_name = self.db_name,
            db_user = self.db_user,
            db_password = self.db_password,
            mail_home_base = self.mail_home_base,
        )
    }

    // ── convenience ────────────────────────────────────────────────

    /// Setters for common fields.

    pub fn set_mail_location(&mut self, loc: &str) {
        self.mail_location = loc.to_string();
    }

    pub fn set_ssl_cert(&mut self, path: &str) {
        self.ssl_cert = path.to_string();
    }

    pub fn set_ssl_key(&mut self, path: &str) {
        self.ssl_key = path.to_string();
    }

    pub fn set_log_path(&mut self, path: &str) {
        self.log_path = path.to_string();
    }

    pub fn set_info_log_path(&mut self, path: &str) {
        self.info_log_path = path.to_string();
    }

    pub fn set_db_credentials(&mut self, user: &str, password: &str, name: &str, host: &str) {
        self.db_user = user.to_string();
        self.db_password = password.to_string();
        self.db_name = name.to_string();
        self.db_host = host.to_string();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_default() {
        let cfg = DovecotConfig::generate_default("example.com");
        assert_eq!(cfg.domain, "example.com");
        assert_eq!(cfg.hostname, "mail.example.com");
        assert!(cfg.ssl_cert.contains("mail.example.com"));
        assert!(cfg.ssl_key.contains("mail.example.com"));
    }

    #[test]
    fn test_10_auth() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_10_auth();
        assert!(out.contains("disable_plaintext_auth = yes"));
        assert!(out.contains("auth_mechanisms = plain login"));
        assert!(out.contains("auth-sql.conf.ext"));
    }

    #[test]
    fn test_10_mail() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_10_mail();
        assert!(out.contains("mail_location = maildir:/var/mail/vhosts/%d/%n/Maildir"));
        assert!(out.contains("namespace inbox"));
        assert!(out.contains("\\Drafts"));
        assert!(out.contains("\\Junk"));
        assert!(out.contains("\\Sent"));
        assert!(out.contains("\\Trash"));
    }

    #[test]
    fn test_10_master() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_10_master();
        assert!(out.contains("dovecot-lmtp"));
        assert!(out.contains("private/auth"));
        assert!(out.contains("user = postfix"));
        assert!(out.contains("user = vmail"));
        assert!(out.contains("port = 993"));
        assert!(out.contains("port = 995"));
    }

    #[test]
    fn test_10_ssl() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_10_ssl();
        assert!(out.contains("ssl = required"));
        assert!(out.contains("ssl_cert = <"));
        assert!(out.contains("ssl_key = <"));
        assert!(out.contains("ssl_min_protocol = TLSv1.2"));
        assert!(out.contains("ssl_prefer_server_ciphers = yes"));
    }

    #[test]
    fn test_10_logging_default() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_10_logging();
        assert!(out.contains("# log_path = syslog"));
    }

    #[test]
    fn test_10_logging_custom() {
        let mut cfg = DovecotConfig::generate_default("example.com");
        cfg.set_log_path("/var/log/dovecot.log");
        cfg.set_info_log_path("/var/log/dovecot-info.log");
        let out = cfg.generate_10_logging();
        assert!(out.contains("log_path = /var/log/dovecot.log"));
        assert!(out.contains("info_log_path = /var/log/dovecot-info.log"));
    }

    #[test]
    fn test_auth_sql_ext() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_auth_sql_ext();
        assert!(out.contains("passdb {"));
        assert!(out.contains("userdb {"));
        assert!(out.contains("driver = sql"));
        assert!(out.contains("dovecot-sql.conf.ext"));
    }

    #[test]
    fn test_dovecot_sql_ext() {
        let cfg = DovecotConfig::generate_default("example.com");
        let out = cfg.generate_dovecot_sql_ext();
        assert!(out.contains("driver = mysql"));
        assert!(out.contains("host=127.0.0.1"));
        assert!(out.contains("dbname=mailserver"));
        assert!(out.contains("user=mailuser"));
        assert!(out.contains("password=changeme"));
        assert!(out.contains("SHA512-CRYPT"));
        // Ensure queries use Dovecot variables, not Rust interpolation
        assert!(out.contains("'%u'"));
        assert!(out.contains("/var/mail/vhosts/"));
    }

    #[test]
    fn test_dovecot_sql_ext_custom_creds() {
        let mut cfg = DovecotConfig::generate_default("example.com");
        cfg.set_db_credentials("myuser", "mypass", "mydb", "db.internal");
        let out = cfg.generate_dovecot_sql_ext();
        assert!(out.contains("host=db.internal"));
        assert!(out.contains("dbname=mydb"));
        assert!(out.contains("user=myuser"));
        assert!(out.contains("password=mypass"));
    }

    #[test]
    fn test_set_mail_location() {
        let mut cfg = DovecotConfig::generate_default("example.com");
        cfg.set_mail_location("mdbox:/srv/mail/%d/%n");
        let out = cfg.generate_10_mail();
        assert!(out.contains("mail_location = mdbox:/srv/mail/%d/%n"));
    }

    #[test]
    fn test_set_ssl() {
        let mut cfg = DovecotConfig::generate_default("example.com");
        cfg.set_ssl_cert("/custom/cert.pem");
        cfg.set_ssl_key("/custom/key.pem");
        let out = cfg.generate_10_ssl();
        assert!(out.contains("ssl_cert = </custom/cert.pem"));
        assert!(out.contains("ssl_key = </custom/key.pem"));
    }

    #[test]
    fn test_imap_plaintext_disabled() {
        let cfg = DovecotConfig::generate_default("example.com");
        let master = cfg.generate_10_master();
        // Port 0 disables plaintext IMAP
        assert!(master.contains("inet_listener imap {\n    port = 0\n  }"));
    }
}
