use std::fmt;

/// SpamAssassin local.cf configuration.
#[derive(Debug, Clone)]
pub struct SpamAssassinConfig {
    /// Score threshold for marking as spam (default 5.0).
    pub required_score: f64,
    /// Subject prefix prepended to spam messages.
    pub rewrite_header_subject: String,
    /// Whether to encapsulate spam in a MIME attachment (0 = no, 1 = yes, 2 = text-only).
    pub report_safe: u8,
    /// Enable Bayes classifier.
    pub use_bayes: bool,
    /// Enable Bayes auto-learning.
    pub bayes_auto_learn: bool,
    /// Enable network-based DNSBL checks.
    pub skip_rbl_checks: bool,
    /// Custom DNSBL entries: (zone, score).
    pub dnsbl_entries: Vec<(String, f64)>,
    /// Enable Pyzor.
    pub use_pyzor: bool,
    /// Enable Razor2.
    pub use_razor2: bool,
    /// Enable DCC.
    pub use_dcc: bool,
}

#[derive(Debug)]
pub enum SpamAssassinConfigError {
    InvalidScore(f64),
}

impl fmt::Display for SpamAssassinConfigError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidScore(s) => write!(f, "Invalid required_score: {}", s),
        }
    }
}

impl std::error::Error for SpamAssassinConfigError {}

impl SpamAssassinConfig {
    /// Produce a config with safe, sensible defaults.
    pub fn generate_default() -> Self {
        Self {
            required_score: 5.0,
            rewrite_header_subject: "[SPAM]".to_string(),
            report_safe: 0,
            use_bayes: true,
            bayes_auto_learn: true,
            skip_rbl_checks: false,
            dnsbl_entries: vec![
                ("zen.spamhaus.org".to_string(), 2.0),
                ("bl.spamcop.net".to_string(), 2.0),
                ("b.barracudacentral.org".to_string(), 2.0),
            ],
            use_pyzor: true,
            use_razor2: true,
            use_dcc: false,
        }
    }

    /// Validate the config.
    pub fn validate(&self) -> Result<(), SpamAssassinConfigError> {
        if self.required_score <= 0.0 || self.required_score > 100.0 {
            return Err(SpamAssassinConfigError::InvalidScore(self.required_score));
        }
        Ok(())
    }

    /// Generate the local.cf content.
    pub fn generate_local_cf(&self) -> String {
        let mut out = String::new();

        out.push_str("# SpamAssassin local.cf - generated by mission-control\n\n");

        // Core settings
        out.push_str(&format!("required_score {:.1}\n", self.required_score));
        out.push_str(&format!(
            "rewrite_header Subject {}\n",
            self.rewrite_header_subject
        ));
        out.push_str(&format!("report_safe {}\n", self.report_safe));
        out.push('\n');

        // Bayes
        out.push_str(&format!(
            "use_bayes {}\n",
            if self.use_bayes { 1 } else { 0 }
        ));
        out.push_str(&format!(
            "bayes_auto_learn {}\n",
            if self.bayes_auto_learn { 1 } else { 0 }
        ));
        out.push('\n');

        // DNSBL
        out.push_str(&format!(
            "skip_rbl_checks {}\n",
            if self.skip_rbl_checks { 1 } else { 0 }
        ));

        if !self.skip_rbl_checks {
            out.push('\n');
            out.push_str("# DNSBL configuration\n");
            for (zone, score) in &self.dnsbl_entries {
                let rule_name = zone
                    .replace('.', "_")
                    .to_uppercase();
                out.push_str(&format!(
                    "header   RCVD_IN_{} eval:check_rbl('{}', '{}')\n",
                    rule_name, zone, zone
                ));
                out.push_str(&format!(
                    "describe RCVD_IN_{} Listed in {}\n",
                    rule_name, zone
                ));
                out.push_str(&format!(
                    "score    RCVD_IN_{} {:.1}\n",
                    rule_name, score
                ));
                out.push('\n');
            }
        }

        // Network checks
        if self.use_pyzor {
            out.push_str("use_pyzor 1\n");
        }
        if self.use_razor2 {
            out.push_str("use_razor2 1\n");
        }
        if self.use_dcc {
            out.push_str("use_dcc 1\n");
        }

        out
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_default() {
        let cfg = SpamAssassinConfig::generate_default();
        assert!((cfg.required_score - 5.0).abs() < f64::EPSILON);
        assert_eq!(cfg.rewrite_header_subject, "[SPAM]");
        assert_eq!(cfg.report_safe, 0);
        assert!(cfg.use_bayes);
        assert!(cfg.bayes_auto_learn);
        assert!(!cfg.skip_rbl_checks);
        assert_eq!(cfg.dnsbl_entries.len(), 3);
    }

    #[test]
    fn test_generate_local_cf() {
        let cfg = SpamAssassinConfig::generate_default();
        let out = cfg.generate_local_cf();
        assert!(out.contains("required_score 5.0"));
        assert!(out.contains("rewrite_header Subject [SPAM]"));
        assert!(out.contains("report_safe 0"));
        assert!(out.contains("use_bayes 1"));
        assert!(out.contains("bayes_auto_learn 1"));
        assert!(out.contains("skip_rbl_checks 0"));
        assert!(out.contains("zen.spamhaus.org"));
        assert!(out.contains("bl.spamcop.net"));
        assert!(out.contains("b.barracudacentral.org"));
    }

    #[test]
    fn test_local_cf_dnsbl_rules() {
        let cfg = SpamAssassinConfig::generate_default();
        let out = cfg.generate_local_cf();
        // Each DNSBL entry should have header, describe, and score lines
        assert!(out.contains("RCVD_IN_ZEN_SPAMHAUS_ORG"));
        assert!(out.contains("RCVD_IN_BL_SPAMCOP_NET"));
        assert!(out.contains("RCVD_IN_B_BARRACUDACENTRAL_ORG"));
    }

    #[test]
    fn test_skip_rbl_checks() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.skip_rbl_checks = true;
        let out = cfg.generate_local_cf();
        assert!(out.contains("skip_rbl_checks 1"));
        // DNSBL rules should not be present when skipped
        assert!(!out.contains("RCVD_IN_"));
    }

    #[test]
    fn test_custom_score() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.required_score = 3.5;
        let out = cfg.generate_local_cf();
        assert!(out.contains("required_score 3.5"));
    }

    #[test]
    fn test_validate_good() {
        let cfg = SpamAssassinConfig::generate_default();
        assert!(cfg.validate().is_ok());
    }

    #[test]
    fn test_validate_bad_score_zero() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.required_score = 0.0;
        assert!(cfg.validate().is_err());
    }

    #[test]
    fn test_validate_bad_score_negative() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.required_score = -1.0;
        assert!(cfg.validate().is_err());
    }

    #[test]
    fn test_validate_bad_score_too_high() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.required_score = 101.0;
        assert!(cfg.validate().is_err());
    }

    #[test]
    fn test_pyzor_razor_settings() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.use_pyzor = true;
        cfg.use_razor2 = true;
        cfg.use_dcc = true;
        let out = cfg.generate_local_cf();
        assert!(out.contains("use_pyzor 1"));
        assert!(out.contains("use_razor2 1"));
        assert!(out.contains("use_dcc 1"));
    }

    #[test]
    fn test_no_pyzor() {
        let mut cfg = SpamAssassinConfig::generate_default();
        cfg.use_pyzor = false;
        let out = cfg.generate_local_cf();
        assert!(!out.contains("use_pyzor"));
    }
}
